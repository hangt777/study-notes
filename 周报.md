# 一、启动Ubuntu时发现问题

## （一）启动不了ubuntu

1.无法正常开启Ubuntu，黑屏，而且无法关闭虚拟机，我便进入任务管理器强行关闭虚拟机进程，结果重启时发现ubuntu已经无法开机

[![2023-12-11-145444.png](https://i.postimg.cc/4dHc3k1g/2023-12-11-145444.png)](https://postimg.cc/bD8r65MC)

通过上网查询这就是虚拟机异常关闭导致。

## （二）解决

通过上网查询我以管理员身份运行虚拟机但还是打不开

[![2023-12-11-145542.png](https://i.postimg.cc/0N4TS3Ln/2023-12-11-145542.png)](https://postimg.cc/kVxY3jMR)

在这一步之后我跟着网上的步骤重启电脑在系统设置中对VMware进行修复

[![2023-12-11-145707.png](https://i.postimg.cc/gJCQrZf2/2023-12-11-145707.png)](https://postimg.cc/hz0p5fDk)

点击修复之后系统自动对这个软件进行修复安装，重启电脑之后我的ubuntu已经可以正常运行

# 二、ROS初学

## （一）命令行使用基础

1.`cd` `[目录名]`：切换文件夹

2.`pwd`：查看当前所在文件夹

3.`mkdir` `[目录名]`：创建目录

4.`ls`：查看当前文件夹下的内容

5.`touch` `[目录名]`：如果文件不存在，新建文件

6.`mv`：移动文件或者目录/文件或者目录重命名

7.`cp` `[源文件]` `[目标文件]`:复制文件或者目录

8.`rm`:删除文件或目录，且不能恢复

9.`sudo` `[选项>]` `[指令]`:以其他身份来执行指令

## （二）c++&python的基本使用

### 1、c++

（1）c++运行需要先编译再运行，因此会有个中间文件

```
g++ [文件名] -o [编译后文件名]
```

（2）运行编译后的文件

```
./[文件名]
```

### 2、python

python的运行比较简单，只需一行代码搞定，没有中间文件

```
 python [文件名]
```

## （三）ROS中的一些核心概念

### 1、节点(Node) 与 节点管理器(Node Master)

[![2023-12-12-212013.png](https://i.postimg.cc/TPyfGpY7/2023-12-12-212013.png)](https://postimg.cc/kVdkvMSK)

### 2、通信模式之一——Topic模式

（1）Message：定义数据的类型，具有一定的数据结构定义

（2）单向性

（3）数据的管道称为Topic（话题）

（4）使用 发布&订阅 模型

（5）话题的消息的接口使用 .msg 文件定义

### 3、通信模式之二——Service模式

（1）使用客户端/服务器（c/s）模型

（2）带有反馈的机制

（3）双向的

（4）服务的数据内容可用 .srv 定义

### 4、两者比较

[![2368e1c650ad36b899a710ef4cde1c9.jpg](https://i.postimg.cc/tTtdgRBP/2368e1c650ad36b899a710ef4cde1c9.jpg)](https://postimg.cc/k6GR1C3X)

### 5、参数(Parameter)

[![aab061200b4246dcb85c75a9ae4dac1e.png](https://i.postimg.cc/VsKG94Ft/aab061200b4246dcb85c75a9ae4dac1e.png)](https://postimg.cc/Z0yx482Y)

（1）参数是一个“字典”

（2）存储在ROS Master服务器，节点可以对参数存储、检索、更新（如图）

（3）适合静态存储、非二进制

### 6、文件系统

[![82d41bfd7e0d49b983ded5a5291735d5.png](https://i.postimg.cc/CxGb7xV2/82d41bfd7e0d49b983ded5a5291735d5.png)](https://postimg.cc/QFMBxsCg)

## （四）ROS命令行工具

### 1、查看系统中的计算图

```
rqt_graph
```

可以清晰地了解系统节点间通信的部分信息。

### 2、rosnode

（1）显示节点列表

```
rosnode list
```

（2）查看节点信息

```
rosnode info /节点名
```

### 3、rostopic

（1）显示topic列表

```
rostopic list
```

（2）手动发布数据给topic

我们来手动发布数据给topic来控制海龟移动，使用`rostopic pub`

```
rostopic pub (参数) 话题名 消息数据结构 “具体数据”
```

### 4、rosmsg

（1）查看消息数据结构

```
rosmsg show 
```

### 5、使用服务通信方式`rosservice`

（1）查看服务列表

```
rosservice list
```

（2）手动通过服务来进行操作

```
rosservice call (参数) 服务名 “具体数据”
```

### 6、话题记录和复现`rosbag`

（1）记录

```
rosbag record -a -O 文件名
```

（2）复现

```
rosbag play 文件名
```

## （五）创建工作空间和编译功能包

### 1、工作空间

**工作空间**（Workspace）：存放工程开发相关文件的文件夹。类似一个IDE（例如Pycharm）新建一个工程，就是一个工作空间。包含4个文件夹

- src：代码空间，放置功能包代码
- build：编译空间，编译过程中产生的中间文件
- devel：开发空间，放置编译生成的可执行文件、库、脚本
- install：安装空间，存放可执行文件

### 2、创建工作空间

（1）创建

```
mkdir -p ~/catkin_ws/src
cd ~/catkin_ws/src
catkin_init_workspace
```

（2）编译空代码的工作空间

```
cd ~/catkin_ws
catkin_make
catkin_make install
```

### 3、创建功能包

**功能包**是放置ROS源码的最小单元。

同一工作空间下，不允许存在同名功能包；不同工作空间下，允许存在同名功能包。

（1）创建

```
catkin_create_pkg <package_name> [depend1] [depend2] [depend3]
```

<package_name>为包名
[depend]为依赖，即指明编译的时候需要ROS中的其他功能包，如需要调用python、C++库，就要指明rospy、roscpp。

```
cd ~/catkin_ws/src
catkin_create_pkg test_pkg std_msgs rospy roscpp
```

（2）编译新的功能包

```
cd ~/catkin_ws
catkin_make
```

### 4、设置和检查环境变量

（1）设置环境变量

```
source ~/catkin_ws/devel/setup.bash
```

（2）检查

```
echo $ROS_PACKAGE_PATH
```

## （六）发布者Publisher的编程实现

### 1、模型图

[![2023-12-18-214646.png](https://i.postimg.cc/15CG0jb9/2023-12-18-214646.png)](https://postimg.cc/bsnSp3zM)

### 2、创建功能包

在src文件夹创建一个新的功能包learning topic

```
cd ~/catkin_ws/src
catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim
```

### 3、创建Publisher代码

- 初始化ROS节点
- 向ROS Master注册节点消息，包括发布的话题名和话题中的消息类型
- 创建消息数据
- 按照一定的频率循环发布消息

[![2023-12-18-220649.png](https://i.postimg.cc/rF8QcHBT/2023-12-18-220649.png)](https://postimg.cc/CdQjscMr)

### 4、编辑代码

（1）配置Publisher代码编译规则

首先需要配置CMakeLists.txt中的编译规则：

- 设置需要编译的代码和生成的可执行文件
- 设置链接库

将下列代码拷贝至CMakeLists.txt中：

```
add_executable(velocity_publisher src/velocity_publisher.cpp)
target_link_libraries(velocity_publisher ${catkin_LIBRARIES})
```

（2）执行编译

```
cd ~/catkin_ws
catkin_make
```

将`source devel/setup.bash`放入环境变量.bashrc中

[![2023-12-18-221806.png](https://i.postimg.cc/FzM7Gw56/2023-12-18-221806.png)](https://postimg.cc/SYGSxTKL)

（3）运行

```
roscore
```

```
rosrun turtlesim turtlesim_node
```

```
rosrun learning_topic velocity_publisher
```

## （七）订阅者Subscriber的编程实现

### 1、模型图

[![2023-12-19-184630.png](https://i.postimg.cc/nVy2V0nF/2023-12-19-184630.png)](https://postimg.cc/F1x3Dbf8)

### 2、创建功能包

### 3、创建Subscriber代码

如何实现一个Subscriber:

- 初始化ROS节点
- 订阅需要的话题
- 循环等待话题消息，接收到消息后进入回调函数
- 在回调函数中完成消息处理

[![2023-12-19-185150.png](https://i.postimg.cc/zGr1hCF5/2023-12-19-185150.png)](https://postimg.cc/TpCSMWsH)

### 4、编译代码

（1）配置代码编译规则

配置CMakeLists.txt中的编译规则：

- 设置需要编译的代码和生成的可执行文件
- 设置链接库

将下列代码拷贝至CMakeLists.txt中：

```
add_executable(pose_subscriber src/pose_subscriber.cpp)
target_link_libraries(pose_subscriber ${catkin_LIBRARIES})
```

（2）执行编译

```
cd ~/catkin_ws
catkin_make
```

（3）运行

```
roscore
```

```
rosrun turtlesim turtlesim_node
```

```
rosrun learning_topic pose_subscriber
```

海龟的位置就会一直被pose_subscriber监听，现在因为海龟没动，所以x、y的坐标值是不会变的

让海龟动起来，再建立一个之前用过的键盘控制节点：

```
rosrun turtlesim turtle_teleop_key
```

控制它移动，坐标就发生实时变化了

## （八）话题消息（Message）的定义与使用

### 1、模型图

[![2023-12-19-185921.png](https://i.postimg.cc/x8n4C5SF/2023-12-19-185921.png)](https://postimg.cc/VrZRZjvj)

### 2、自定义话题消息

（1）定义msg文件

①在learning_topic的功能包根目录下，新建文件夹 msg
并创建新文件 Person.msg，创建方法为使用`touch`命令在当前目录输入：

```
touch Person.msg
```

②将代码复制进Person.msg

```
string name
uint8 sex
uint8 age

uint8 unknown = 0
uint8 male = 1
uint8 female = 2
```

（2）在package.xml中添加功能包依赖

打开package.xml文件，将下面代码拷到文件指定位置：

```
<build_depend>message_generation</build_depend>
<exec_depend>message_runtime</exec_depend>
```

build_depend为编译依赖，这里依赖的是一个会动态产生message的功能包
exer_depend为执行依赖，这里依赖的是一个动态runtime运行的功能包

（3）在CMakeLists.txt中添加编译选项

```
find_package( ...... message_generation)

add_message_files(FILES Person.msg)
generate_messages(DEPENDENCIES std_msgs)

catkin_package( ...... message_runtime)
```

（4）编译

```
catkin_make
```

### 3、创建代码并编译运行

（1）创建代码

person_publisher.cpp

[![2023-12-19-190727.png](https://i.postimg.cc/MHYV6bW5/2023-12-19-190727.png)](https://postimg.cc/ZvCCjNvv)

person_subscriber.cpp

[![2023-12-19-190753.png](https://i.postimg.cc/mrMcZNj9/2023-12-19-190753.png)](https://postimg.cc/DWvfBGtf)

（2）编译

先配置CMakeLists.txt编译规则

- 设置需要编译的代码和生成的可执行文件；
- 设置链接库；
- 添加依赖项。

```
add_executable(person_publisher src/person_publisher.cpp)
target_link_libraries(person_publisher ${catkin_LIBRARIES})
add_dependencies(person_publisher ${PROJECT_NAME}_generate_messages_cpp)

add_executable(person_subscriber src/person_subscriber.cpp)
target_link_libraries(person_subscriber ${catkin_LIBRARIES})
add_dependencies(person_subscriber ${PROJECT_NAME}_generate_messages_cpp)
```

然后编译：

```
cd ~/catkin_ws
catkin_make
```

（3）运行

```
roscore
```

```
rosrun learning_topic person_subscriber
```

```
rosrun learning_topic person_publisher
```

计算图

[![2023-12-19-191304.png](https://i.postimg.cc/FHwZnp1k/2023-12-19-191304.png)](https://postimg.cc/sM97MpY3)

如果我们将roscore关掉，可以看到subscriber和publisher依然在接发。roscore代表了ROS Master，它帮助subscriber和publisher建立通信连接，连接建立后退出舞台也没什么问题了。
但是关闭ROS Master就不能管理这个连接了。同时也无法看到rqt_graph。

## （九）客户端Client的编程实现

### 1.模型图

[![2024-01-01-200449.png](https://i.postimg.cc/qRL6HM5w/2024-01-01-200449.png)](https://postimg.cc/ygD8FBB3)

### 2.创建功能包

创建新的功能包 learning_service：

```
cd ~/catkin_ws/src
catkin_create_pkg learning_service roscpp rospy std_msgs geometry_msgs turtlesim
```

### 3.创建代码并编译运行

（1）如何实现一个客户端Client

- 初始化ROS
- 创建一个Client实例
- 发布服务请求数据
- 等待Server处理之后的应答结果

[![2024-01-01-200746.png](https://i.postimg.cc/7YTPgZnR/2024-01-01-200746.png)](https://postimg.cc/jLtrTK96)

（2）编译

```
cd ~/catkin_ws
catkin_make
```

（3）运行

```
roscore
```

```
rosrun turtlesim turtlesim_node
```

```
rosrun learning_service turtle_spawn
```



# 三、串口通信学习

## （一）通用同步异步收发器（USART）

### 1.概述

STM32上的USART外设可以实现同步传输功能，所以外设名为USART，比UART多了一个S，即synchronous（同步）

- STM32和PC通信模型：

  [![2023-12-28-155449.png](https://i.postimg.cc/288RJ91F/2023-12-28-155449.png)](https://postimg.cc/hhw5Qrbf)

- STM32和PC通过RS-232标准通信：

  [![2023-12-28-155708.png](https://i.postimg.cc/13vpBtLr/2023-12-28-155708.png)](https://postimg.cc/68G25968)

- RS-232协议电平标准对比：

  [![2023-12-28-155820.png](https://i.postimg.cc/jjGn3JvP/2023-12-28-155820.png)](https://postimg.cc/Y4zSh05C)

- RS-232标准数据传输协议层：

  串口通讯的数据包由发送设备通过自身的 TXD 接口传输到接收设备的 RXD 接口。在串口通讯的协议层中，规定了数据包的内容，它由起始位、主体数据、校验位以及停止位组成，通讯双方的数据包格式要约定一致才能正常收发数据，其组成见图。

  [![2023-12-28-160008.png](https://i.postimg.cc/mkTYVH2V/2023-12-28-160008.png)](https://postimg.cc/cg5tL638)



### 2.协议概念

- 波特率

  本章中主要讲解的是串口异步通讯，异步通讯中由于没有时钟信号(如前面讲解的 DB9接口中是没有时钟信号的)，所以两个通讯设备之间需要约定好波特率，即每个码元的长度，以便对信号进行解码， 图中用虚线分开的每一格就是代表一个码元。常见的波特率为4800、 9600、 115200 等。

- 通讯的起始和停止信号

  串口通讯的一个数据包从起始信号开始，直到停止信号结束。数据包的起始信号由一个逻辑 0 的数据位表示，而数据包的停止信号可由 0.5、 1、 1.5 或 2 个逻辑 1 的数据位表示，只要双方约定一致即可。

- 有效数据

  在数据包的起始位之后紧接着的就是要传输的主体数据内容，也称为有效数据，有效数据的长度常被约定为 5、 6、 7 或 8 位长。

- 数据校验

  在有效数据之后，有一个可选的数据校验位。由于数据通信相对更容易受到外部干扰导致传输数据出现偏差，可以在传输过程加上校验位来解决这个问题。校验方法有奇校验(odd)、偶校验(even)、 0 校验(space)、 1 校验(mark)以及无校验(noparity)。

  [![2023-12-28-160741.png](https://i.postimg.cc/L8WG7HPj/2023-12-28-160741.png)](https://postimg.cc/CRjvnpmK)

- 外设框图

  其中TX和RX使用GPIO引脚作为输入输出，涉及到GPIO引脚的复用功能

  [![2023-12-28-161223.png](https://i.postimg.cc/fbhfkpn6/2023-12-28-161223.png)](https://postimg.cc/pmqF60dZ)

  

## （二）I2C ——读写 EEPROM

### 1.I2C 协议简介

（1）I2C 物理层

I2C通讯设备之间的常用连接方式见图

[![2024-01-01-184949.png](https://i.postimg.cc/X7cQPVsH/2024-01-01-184949.png)](https://postimg.cc/SJR62pFC)

它的物理层有如下特点：

- 它是一个支持设备的总线。“总线”指多个设备共用的信号线。在一个 I2C 通讯总线中，可连接多个 I2C 通讯设备，支持多个通讯主机及多个通讯从机。
- 一个 I2C 总线只使用两条总线线路，一条双向串行数据线 (SDA) ，一条串行时钟线 (SCL)。数据线即用来表示数据，时钟线用于数据收发同步。
- 每个连接到总线的设备都有一个独立的地址，主机可以利用这个地址进行不同设备之间的访问。
- 总线通过上拉电阻接到电源。当 I2C 设备空闲时，会输出高阻态，而当所有设备都空闲，都输出高阻态时，由上拉电阻把总线拉成高电平。
- 多个主机同时使用总线时，为了防止数据冲突，会利用仲裁方式决定由哪个设备占用总线。
- 具有三种传输模式：标准模式传输速率为 100kbit/s ，快速模式为 400kbit/s ，高速模式下可达 3.4Mbit/s，但目前大多 I2C 设备尚不支持高速模式。
- 连接到相同总线的 IC 数量受到总线的最大电容 400pF 限制。

（2）协议

​		I2C 的协议定义了通讯的起始和停止信号、数据有效性、响应、仲裁、时钟同步和地址广播等环节。

I2C 通讯过程的基本结构：

[![2024-01-01-185510.png](https://i.postimg.cc/T2HRD6Vs/2024-01-01-185510.png)](https://postimg.cc/3WmMszbj)

这些图表示的是主机和从机通讯时， SDA 线的数据包序列。

​		其中 S 表示由主机的 I2C 接口产生的传输起始信号 (S)，这时连接到 I2C 总线上的所有从机都会接收到这个信号。

​		起始信号产生后，所有从机就开始等待主机紧接下来广播的从机地址信号。在 I2C 总线上，每个设备的地址都是唯一的，当主机广播的地址与某个设备地址相同时，这个设备就被选中了，没被选中的设备将会忽略之后的数据信号。根据 I2C 协议，这个从机地址可以是 7 位或 10 位。

​		在地址位之后，是传输方向的选择位，该位为 0 时，表示后面的数据传输方向是由主机传输至从机，即主机向从机写数据。该位为 1 时，则相反，即主机由从机读数据。

​		从机接收到匹配的地址后，主机或从机会返回一个应答 (ACK) 或非应答 (NACK) 信号，只有接收到应答信号后，主机才能继续发送或接收数据。

- 写数据

  若配置的方向传输位为“写数据”方向，广播完地址，接收到应答信号后，主机开始正式向从机传输数据 (DATA)，数据包的大小为 8 位，主机每发送完一个字节数据，都要等待从机的应答信号 (ACK)，重复这个过程，可以向从机传输 N 个数据，这个 N 没有大小限制。当数据传输结束时，主机向从机发送一个停止传输信号 (P)，表示不再传输数据。

- 读数据

  若配置的方向传输位为“读数据”方向，广播完地址，接收到应答信号后，从机开始向主机返回数据 (DATA)，数据包大小也为 8 位，从机每发送完一个数据，都会等待主机的应答信号 (ACK)，重复这个过程，可以返回 N 个数据，这个 N 也没有大小限制。当主机希望停止接收数据时，就向从机返回一个非应答信号 (NACK)，则从机自动停止数据传输。

- 读和写数据

  除了基本的读写， I2C 通讯更常用的是复合格式，该传输过程有两次起始信号 (S)。一般在第一次传输中，主机通过 SLAVE_ADDRESS 寻找到从设备后，发送一段“数据”，这段数据通常用于表示从设备内部的寄存器或存储器地址；在第二次的传输中，对该地址的内容进行读或写。也就是说，第一次通讯是告诉从机读写地址，第二次则是读写的实际内容。

起始信号：

[![2024-01-01-191110.png](https://i.postimg.cc/Z5j92gtz/2024-01-01-191110.png)](https://postimg.cc/VJrLbKkK)

数据有效性：

[![2024-01-01-191314.png](https://i.postimg.cc/y6F825cp/2024-01-01-191314.png)](https://postimg.cc/s1gzhTn5)

地址及数据方向：

[![2024-01-01-191430.png](https://i.postimg.cc/02VPsqQn/2024-01-01-191430.png)](https://postimg.cc/PPvBW91v)

响应：

[![2024-01-01-191600.png](https://i.postimg.cc/SKWPmWd4/2024-01-01-191600.png)](https://postimg.cc/yJ8jP32p)

### 2.STM32 的 I2C 特性及架构

（1）外设简介

​		STM32 的 I2C 外设可用作通讯的主机及从机，支持 100Kbit/s 和 400Kbit/s 的速率，支持 7 位、10 位设备地址，支持 DMA 数据传输，并具有数据校验功能。它的 I2C 外设还支持 SMBus2.0 协议，SMBus 协议与 I2C 类似。

（2）架构

[![2024-01-01-192007.png](https://i.postimg.cc/sDh4F3wd/2024-01-01-192007.png)](https://postimg.cc/mtTHCfv8)

（3）数据控制逻辑

​		I2C 的 SDA 信号主要连接到数据移位寄存器上，数据移位寄存器的数据来源及目标是数据寄存器 (DR)、地址寄存器 (OAR)、 PEC 寄存器以及 SDA 数据线。当向外发送数据的时候，数据移位寄存器以“数据寄存器”为数据源，把数据一位一位地通过 SDA 信号线发送出去；当从外部接收数据的时候，数据移位寄存器把 SDA 信号线采样到的数据一位一位地存储到“数据寄存器”中。若使能了数据校验，接收到的数据会经过 PCE 计算器运算，运算结果存储在 “PEC 寄存器”中。当 STM32 的 I2C 工作在从机模式的时候，接收到设备地址信号时，数据移位寄存器会把接收到的地址与 STM32 的自身的“ I2C 地址寄存器”的值作比较，以便响应主机的寻址。 STM32 的自身 I2C 地址可通过修改“自身地址寄存器”修改，支持同时使用两个 I2C 设备地址，两个地址分别存储在 OAR1 和 OAR2 中。

（4）体控制逻辑

​		整体控制逻辑负责协调整个 I2C 外设，控制逻辑的工作模式根据我们配置的“控制寄存器(CR1/CR2)”的参数而改变。在外设工作时，控制逻辑会根据外设的工作状态修改“状态寄存器 (SR1 和 SR2)”，我们只要读取这些寄存器相关的寄存器位，就可以了解 I2C 的工作状态。除此之外，控制逻辑还根据要求，负责控制产生 I2C 中断信号、 DMA 请求及各种 I2C 的通讯信号(起始、停止、响应信号等)。

## （三）QSPI-读写串行FLASH

### 1.简介

QSPI 是一种专用的通信接口，连接单、双或四（条数据线） SPI Flash 存储介质。可以在以下三种模式下工作:

- 间接模式：使用 QSPI 寄存器执行全部操作
- 状态轮询模式：周期性读取外部 Flash 状态寄存器，而且标志位置 1 时会产生中断（如擦除或烧写完成，会产生中断）
- 内存映射模式：外部 Flash 映射到微控制器地址空间，从而系统将其视作内部存储器

（1）功能框图

[![2024-01-01-194509.png](https://i.postimg.cc/wj6vHVg5/2024-01-01-194509.png)](https://postimg.cc/ZCMZx690)

（2）命令序列

​		QSPI 通过命令与 Flash 通信 每条命令包括指令、地址、交替字节、空指令和数据这五个阶段 任一阶段均可跳过，但至少要包含指令、地址、交替字节或数据阶段之一。

[![2024-01-01-195005.png](https://i.postimg.cc/D0BNGn4w/2024-01-01-195005.png)](https://postimg.cc/xNNgDrPw)

### 2.信号接口协议模式

（1）单线 SPI 模式

​		传统 SPI 模式允许串行发送/接收单独的 1 位。在此模式下，数据通过 SO 信号（其 I/O 与IO0 共享）发送到 Flash。从 Flash 接收到的数据通过 SI（其 I/O 与 IO1 共享）送达。在每个已配置为单线模式的阶段中：

- IO0 (SO) 处于输出模式
- IO1 (SI) 处于输入模式（高阻抗）
- IO2 处于输出模式并强制置“0”（以禁止“写保护”功能）
- IO3 处于输出模式并强制置“1”（以禁止“保持”功能）

（2）双线 SPI 模式

​		在双线模式下，通过 IO0/IO1 信号同时发送/接收两位。通过将 QUADSPI_CCR 寄存器的 IMODE/ADMODE/ABMODE/DMODE 字段设置为 10，在每个已配置为单线模式的阶段中：

- IO0/IO1 在数据阶段进行读取操作时处于高阻态（输入），在其他情况下为输出
- IO2 处于输出模式并强制置“0”
- IO3 处于输出模式并强制置“1” 

（3）四线 SPI 模式

​		在四线模式下，通过 IO0/IO1/IO2/IO3 信号同时发送/接收四位。通过将 QUADSPI_CCR 寄存器的 IMODE/ADMODE/ABMODE/DMODE 字段设置为 11，在每个已配置为四线模式的阶段中,IO0/IO1/IO2/IO3 在数据阶段进行读取操作时均处于高阻态（输入），在其他情况下为输出。















