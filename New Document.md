**TCP网络分层简述**

1. 应用层  

2. 传输层

3. 网络互联层 

4. 网络访问层

5. 网络介质层

   [^下三个实现主机和主机之间的通信]: 

   *抓包工具：wireshake*

![响应界面](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-09 175649.png) 

一、**应用层**代表协议：HTTP

http:两点之间传输数据的规范，传输内容为超文本。

请求响应过程：首先通过DNS得到目标地址，再通过层层路由访问目标服务器（http1.0非持久）

http1.1建立持久连接，但由于是以明文格式进行传输，不安全，就在http与tcp之间加入了安全传输层ssl协议

http请求报文格式：

![img](https://img-blog.csdn.net/20131107150723906)

| 请求头          | 说明                                                |
| --------------- | --------------------------------------------------- |
| Host            | 接受请求的服务器地址，可以是IP:端口号，也可以是域名 |
| User-Agent      | 发送请求应用程序名称                                |
| Connection      | 指定与连接相关的属性，如Connection:Keep-Alive       |
| Accept-Charset  | 通知服务端可以发送的编码格式                        |
| Accept-Encoding | 通知服务端可以发送的数据压缩格式                    |
| Accept-Language | 通知服务端可以发送的语言                            |



![](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-12 104440.png)

http响应报文格式：

![img](https://img-blog.csdn.net/20131107163544468)

**状态行**：由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔

状态代码为3位数字，200~299的状态码表示成功，300~399的状态码指资源重定向，400~499的状态码指客户端请求出错，500~599的状态码指服务端出错（HTTP/1.1向协议中引入了信息性状态码，范围为100~199）![](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-12 105948.png)

![](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-12 110125.png)

二、**传输层**主要协议：TCP、UDP
TCP  
**1对1**连接的、稳定可靠（保证一定能到达接收端）、字节流。两个主机进程间**端对端**的连接，头部格式极其复杂。  
头部格式：

![](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-12 112049.png)

  ![](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-12 112329.png)![](C:\Users\96059\Pictures\Screenshots\屏幕截图 2024-01-12 111806.png)

**三次握手建立连接**：解决网络信道不可靠问题，防止客户端和服务端建立重复连接

一包数据会分成多个包进行发送，这就涉及到了**丢包问题**，这些数据包到达的顺序不同，就涉及到了**乱序问题**。

TCP为每一个协议都建立了一个**发送缓冲区**，建立的第一个序列号为0，后面每一个字节序列号+1.

| 序列号(ACK) | 长度 | 数据内容 |
| ----------- | ---- | -------- |

如果丢失了100-199这个数据包，接收端就向发送端ACK=100请求这段报文进行补齐。

**第一次握手**：前提服务器打开属于监听状态，客服端向服务端发送一个SYN报文，首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。此时客服端处于SYN-SEND状态。

**第二次握手**：服务器收到客户端的 SYN 报文之后，会以自己的 SYN +ACK报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_RCVD 的状态。

在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。

**第三次握手**：客户端收到 SYN +ACK报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。

确认报文段ACK=1，确认号ack=y+1，序号seq=x+1（初始为seq=x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。
 TCP的**4次挥手断开连接**
**第一次挥手**：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。    
（FIN=1，序号seq=u） 等待服务端的确认  
**第二次挥手**：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。  
 （ACK=1，确认号ack=u+1，序号seq=v） 此时的TCP处于半关闭状态， 客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。此时服务端还可以向客户端发送数据。  
**第三次挥手**：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
 （FIN=1，ACK=1，序号seq=w，确认号ack=u+1）等待客户端的确认。  
**第四次挥手**：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。  
 （ACK=1，seq=u+1，ack=w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。是为了确保服务端收到了ACK报文，如果没收到，服务端会在TIME_WAIT这段时间里重新发送FIN。

**流量控制**

由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。

适用于对网络通讯质量要求较高的场景，准确无误的传输给对方。  
应用场景：发送邮件、传输文件、浏览网页···  

2.UDP 

无需建立连接，类似于群发短信 ，不能确定对方是否接受到了消息。

将数据包从网卡发送，数据包之间没有状态上的联系。

 无需连接：一对多  

是用于对实时性要求较高，但对少量丢包没有要求的场景。还适用于隧道网络（VPN、SDN中的VXLAN)

应用场景： 域名查询、语音通话、视频直播···

三、**网络互联层**：

主要作用是实现终端节点之间的通信。这种终端节点之间的通信，也叫**点对点通信**。

IP：32位二进制数8位为组，转换为十进制，

IP 地址由**网络号**（网段地址）和**主机号**（主机地址）两部分组成，由**子网掩码**进行区分。**网络号**是设备所在区域的一种标识，网络号相同的设备位于同一个网段内，网络号不同的设备通过路由器实现通信。**主机号**是在同一个网段中不同设备的标识，不允许同一个网段内出现重复的主机号。

IP分为公有IP和私有IP，公有IP不能重复，私有IP可以重复。

 IP地址分为四类，分别是 **A 类**、 **B 类**、 **C 类**、 **D 类**（还有一个保留的 E 类）

![img](https://pic4.zhimg.com/80/v2-9e3f252d8fd053c3b63f85837ca720bf_720w.webp)

当主机号全为 0 时，表示的是**网段地址**，非主机地址。当主机号全为 1 时是**广播地址**，也不是主机地址。因此在分配 IP 地址过程中，需要**排除**这两个地址。

IP 地址中的主机号全部为 1 的就是**广播地址**，它是向同一个网段中的所有主机发送数据包。

A 类 IP 地址是首位以“ 0 ”开头的地址。从第 1 位到第 8 位是它的网络号，**网络号**的范围是 `0 ~ 127` 。其中 0 和 127 属于保留地址，减去两个保留地址，因此有 126 个可用的 A 类地址。

B 类 IP 地址是前两位以“ 10 ”开头的地址。从第 1 位到第 16 位是它的**网络号**，网络号的范围是 `128.0 ~ 191.255` 。其中 128.0 和 191.255 属于保留地址，减去两个保留地址，因此有 16382 个可用的 B 类地址。

C 类 IP 地址是前三位以“ 110 ”开头的地址。从第 1 位到第 24 位是它的**网络号**，网络号的范围是 `192.0.0 ~ 223.255.255` 。其中 192.0.0 和 223.255.255 属于保留地址，减去两个保留地址，因此有 2097150 个可用的 C 类地址。

类 IP 地址是前四位以“ 1110 ”开头的地址。从第 1 位到第 32 位是它的网络号，网络号的范围是 `224.0.0.0 ~ 239.255.255.255` 。D 类地址没有主机号，用于**组播**。因此 IP 地址前四位是“ 1110 ”开头的，就是组播地址。剩下的 28 位就是组播的组编号。组播的地址范围是 `224.0.0.0 ~ 239.255.255.255` ，其中 `224.0.0.0 ~ 224.0.0.255` 既可以在同一个网段内实现组播，又可以跨网段给全网所有组员发送组播包。

**组播**用于将包发送给特定组内的所有主机。

![img](https://pic2.zhimg.com/80/v2-4040adc1d6eea6684483b93a6ba421b5_720w.webp)

### 子网掩码

 如今网段地址的长度可变， 需要标识来获取网段地址，以便路由器对数据包进行转发，这种识别码就是**子网掩码**。

子网掩码用 32 位的二进制表示，  IP 地址有多少位网段地址，子网掩码就有多少位取 1 ，其余都取 0 。 ，每 8 位为一组，以“ . ”隔开，再转换为十进制数。

例如： `201.20.100.25` 的子网掩码是 `255.255.255.0` ，算出它的网段地址。

将子网掩码和 IP 地址进行**与（ AND ）运算**，可得到这个 IP 地址的网段地址。

![img](https://pic4.zhimg.com/80/v2-c2411f0c1789c481ca4e18d0a009b2eb_720w.webp)

IP 地址的另一种表示方式是在每个 IP 地址后面追加网络号的位数用“ **/** ”隔开。例如： `201.20.100.25/255.255.255.0` 可表示为 `201.20.100.25/24` 。

解决 IP 地址浪费问题，除了使用子网掩码，还使用了 **CIDR** 和 **VLSM** 技术。

CIDR 是主机号**向网络号借位**，目的是把几个网络汇总成一个大的网络，增加子网主机数量；

VLSM 是网络号**向主机号借位**，目的是把一个标准的网络划分成几个子网，减少子网主机数量。

### 公网地址与私有地址

IP 地址分为**公网地址**和私有地址。公网地址是在互联网上使用的，私有地址是在局域网中使用的。

**公网地址**由 Internet NIC 负责分配，通过它直接访问互联网。

![img](https://pic3.zhimg.com/80/v2-e0c227df1503e89785eeb8a03be36562_720w.webp)

**私有地址**是一段保留的 IP 地址。只在局域网中使用，无法在互联网上使用。但是私有地址可以通过 NAT 技术，将私有地址转换为公网地址接入互联网。

![img](https://pic4.zhimg.com/80/v2-77e65904bd9b38531d6d023164eb8fdf_720w.webp)

 **IP 路由**是设备根据 IP 地址对数据进行转发的操作。当一个数据包到达路由器时，路由器根据数据包的目的地址查询据传递至本地局域网之外的机器的过程。路由器是根据目的 IP 地址的**网络号**进行路由。路由表三要素：目标网络地址、下一跳路由、网络接口。

**路由表**

为了将数据包发给目的节点，所有节点都维护着一张路由表。**路由表**记录 IP 数据在下一跳应该发给哪个路由器。 IP 包将根据这个路由表在各个数据链路上传输。

Hop ，中文叫“跳”。它是指网络中的一个区间。 IP 包就是在网络中一跳一跳的转发，在每一个区间内决定 IP 包下一跳的路径。

一跳是指数据链路中广播域的区间，也就是说不经过路由器而能直接到达的相连主机或路由器网卡的一个区间。

路由表的生成方式有两种：一种是手动设置，也叫**静态路由**。另一种是路由器之间通过交换信息自动刷新，也叫**动态路由**。

![img](https://pic2.zhimg.com/80/v2-394668cfb6089bba11a132365d7f99d1_720w.webp)

**默认路由**

**默认路由**是指路由表中任何一个地址都能与之匹配的条目。所有数据包都可以使用默认路由进行数据转发。默认路由为 **0.0.0.0/0** 或 **default** 。

**主机路由**

“ IP地址/32 ”被称为**主机路由**，它是路由表中指向单个 IP 地址或主机名的路由条目。例如： 192.168.153.15/32 就是一条主机路由，表示整个 IP 地址的所有位都将参与路由。

**回环地址**

以 127 开头的 IP 地址都是**环回地址**，其所在的回环接口可以理解为虚拟网卡。使用回环地址时，数据包会直接被主机的 IP 层获取，而不经过链路层，也不会流向网络。一般用来检查主机上运行的网络服务是否正常。

### 路由汇总

**路由汇总**主要是为了减少路由条目，把可以聚合的路由汇聚为一个大网络。

路由表越大，查找路由表所需的内存和 CPU 也就越多，时间也会越长，导致转发 IP 数据包的性能下降。如果想要搭建大规模、高性能的网络，就需要尽可能的减小路由表的大小。

### IP 分片与重组

### 数据链路不同， MTU 则不同

每种数据链路的最大传输单元（ MTU ）不同，网络层的 IP 是数据链路的上一层， IP 通过**分片**屏蔽数据链路的差异，实现不同数据链路互通。从 IP 的上一层看，它完全可以**忽略**各个数据链路上的 MTU ，只需要按照源 IP 地址发送的长度接收数据包。

![img](https://pic2.zhimg.com/80/v2-2d211bc7183ef4bbb930a4b47ede12c9_720w.webp)

### IP 报文的分片与重组

当遇到 IP 数据包大于数据链路 MTU 时，往往无法直接发送出去，主机或路由器就会对 IP 数据包进行**分片**处理。

经过分片后的 IP 数据，只会在目标主机上进行**重组**，中途经过路由器时不会进行重组。

![img](https://pic3.zhimg.com/80/v2-8693f05cc4439531c2a87b837eb467d2_720w.webp)

### 路径MTU发现

分片机制有两点不足：

- 加重路由器的处理性能；
- 在分片传输中，一旦某个分片丢失，会造成整个 IP 数据包作废。

为了解决这个问题，要使用**路径 MTU 发现**（ Path MTU Discovery ）技术。路径 MTU 是指从发送端主机到接收端主机之间不需要分片时最大 MTU 值。即路径中存在的所有数据链路中**最小的 MTU** 。路径 MTU 发现是从发送主机按照路径 MTU 的值将数据报分片后进行发送，避免在中途的路由器上进行分片处理。

路径 MTU 发现的**工作原理**如下：

1. 发送端主机发送 IP 数据包时将其头部的**分片禁止标志位**设置为 1 。根据这个标志位，途中的路由器即使收到需要分片的大包，也不会分片，而是直接将包丢弃。之后通过一个 ICMP 不可达消息将数据链路上 MTU 值给发送端主机。
2. 发送端主机根据收到的 MTU 值对数据包进行分片处理，再把 IP 数据包发送给相同的目的主机。如此重复，直到数据包被发送到目标主机为止没有再收到任何 ICMP ，就认为最后一次 ICMP 所通知的 MTU 即是一个合适的 MTU 值。 MTU 值至少可以缓存约 10 分钟，在这 10 分钟内使用刚得到的 MTU ，过了 10 分钟后就重新做一次路径 MTU 发现。

上面的例子是 **UDP** ，如果是在 **TCP** 的情况下，根据路径 MTU 的大小计算出最大段长度（ MSS ），然后再根据这些信息进行数据包的发送。因此，在 TCP 中如果使用路径 MTU 发现， IP 层则不会再分片。

### 路由器三层转发原理

路由器有多个端口，分别连接不同的数据链路。它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行转发，路由表中有**匹配**的路由条目才会转发，无匹配的路由条目则直接丢弃。路由条目既可以手动设置静态路由，也可以通过路由协议自动生成动态路由。

路由器如何进行三层转发？

当一台路由器收到一个数据包时，会执行如下步骤：

1.对数据包进行**解封装**。

通过解封装，查看网络层头部信息的**目的 IP 地址**。

2.在路由表中查找匹配的**路由条目**。

查找匹配的路由条目，就需要将数据包的目的 IP 地址与各个路由条目的网段地址先进行二进制**与（ AND ）运算**，再将运算结果与路由条目的网段地址进行**比较**，若一致则该条目与目的 IP 地址相匹配。最后，与所有路由条目完成运算和比较，可得到一条或多条相匹配的路由条目。也可能没有匹配的路由条目，那么丢弃数据包。(如果路由表中有多条路由条目都匹配数据包的目的 IP 地址，则路由器会选择掩码长度最长的路由条目，这种匹配方式称为**最长匹配原则**。）

3.将数据包按照相应路由条目进行**转发**。

路由条目中包含**下一跳**和**出接口**。当路由器找到相应的路由条目后，它就会根据对应的下一跳和出接口，将数据包从出接口发送数据给下一跳设备。

地址解析协议，简称 **ARP** 协议。是根据目的设备的 IP 地址来查询对应 MAC 地址的协议。

### ARP 的工作原理

**一、**当主机 A 向**同一个网段**内的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。

1、**ARP 请求**：主机 A 以主机 C 的 IP 地址为目的 IP 地址，以广播 MAC 地址为目的 MAC 地址，在同网段内发送这个广播报文，这个报文就叫 **ARP 请求报文**。

二层交换机不查看 IP 地址，根据目的 MAC 地址将报文除接收端口外的所有端口发送。

2、**ARP 响应**：主机 C 发现目的 IP 地址是自己的 IP 地址，于是主机 C 以自己 MAC 地址和 IP 地址作为源 MAC 地址和源 IP 地址，以主机 A 的 MAC 地址和 IP 地址作为目的 MAC 地址和目的 IP 地址，发送响应报文给主机 A ，这个报文就叫 **ARP 响应报文**。其它主机收到主机 A 的 ARP 请求报文，因为目的 IP 地址不是自己的 IP 地址，因此不会进行响应。

当主机 A 在发送 ARP 广播请求报文时，二层交换机已经有主机 A 的 MAC 地址表条目。当收到主机 C 发送的单播 ARP 响应报文时，二层交换机将报文从相应端口发送出去。并将主机 C 的 MAC 地址和对应端口记录到 MAC 地址表中。

3、**更新 ARP 缓存表**：主机 A 收到 ARP 响应报文后，将主机 C 的 IP 地址和 MAC 地址记录到 ARP 缓存表中。下次再向主机 C 发送数据时，直接将缓存的目的 MAC 地址进行封装。

二、当主机 A 向**不同网段**的主机 C 发送数据，但是不知道主机 C 的 MAC 地址。

1、主机 A 使用主机 C 的 IP 地址查询 ARP ，ARP 发现主机 C 不在同一个网段，需要通过**默认网关**（即默认路由的下一跳地址），但是此时没有网关 MAC 地址；

主机 A 先将发送给主机 C 的数据放入缓存中，然后发送 ARP 请求报文，主机 A 以网关 IP 地址为目的 IP 地址发送 **ARP 广播请求报文**；

2、路由器收到 ARP 广播请求报文后，将主机 A 的 MAC 地址和对应端口添加到自己的 MAC 表中，然后查看目的 IP 地址发现是请求自己的 MAC 地址，于是单播发送 **ARP 响应报文**；

3、主机 A 收到 ARP 响应报文后，将发送给主机 C 的数据封装**网关 MAC 地址**为目的 MAC 地址进行发送；

4、路由器收到报文后，查看目的 IP 地址，是发送给主机 C 的，于是查询路由表从相应端口发送数据。由于没有主机 C 的 MAC 地址，路由器发送 **ARP 请求报文**，源 MAC 地址和源 IP 地址替换为发送端口（路由器）的MAC 地址和 IP 地址；

5、主机 C 收到 ARP 请求报文后，添加路由器的端口和 MAC 地址到 MAC 地址表，单播发送 **ARP 响应报文**；

6、 路由器收到主机 C 的 MAC 地址后，将其添加到 MAC 地址表中。将主机 A 发送给主机 C 的报文重新封装，以自己的 MAC 地址为源 MAC 地址，以主机 C 的 MAC 地址为目的 MAC 地址，发送给主机 C ；

7、主机 C 收到主机 A 发送的数据，发送过程结束。

当主机 C 向主机 A 发送回复报文时，同主机 A 向主机 C 发送数据的步骤一致。

### ARP 代理

如果 ARP 请求是从一个网络的主机发往同一网段却不在同一物理网络上的另一台主机，那么连接它们的具有代理 ARP 功能的设备就可以回答该请求，这个过程称作**代理 ARP** 。

代理 ARP 功能屏蔽了分离的物理网络，让用户使用起来，跟在同一个物理网络上一样。

### 免费 ARP

**免费 ARP** 是一种特殊的 ARP 请求，它并非通过 IP 找到对应的 MAC 地址，而是当主机启动的时候，发送一个免费 ARP 请求，即请求自己的 IP 地址的 MAC 地址。

与普通 ARP 请求报文的区别在于报文中的目标 IP 地址。普通 ARP 报文中的目标 IP 地址是其它主机的 IP 地址；而免费 ARP 的请求报文中，**目标 IP 地址是自己的 IP 地址**。

免费 ARP 的作用：

- 起到一个**宣告**作用。它以广播的形式将数据包发送出去，不需要得到回应，只为了告诉其它主机自己的 IP 地址和 MAC 地址。

- 可用于**检测 IP 地址冲突**。当一台主机发送了免费 ARP 请求报文后，如果收到了 ARP 响应报文，则说明网络内已经存在使用该 IP 地址的主机。

- 可用于**更新**其它主机的 ARP 缓存表。如果该主机更换了网卡，而其它主机的 ARP 缓存表仍然保留着原来的 MAC 地址。这时，通过免费的 ARP 数据包，更新其它主机的 ARP 缓存表。

  ### ICMP

  IP 提供尽力而为的服务，指为了把数据包发送到目的地址尽最大努力。它并不做对端目的主机是否收到数据包的验证，无法保证服务质量。

  **ICMP**（互联网控制消息协议）是提供这类功能的一种协议。ICMP 的主要功能包括，确认 IP 包是否成功送达目的地址，通知发送过程中 IP 包被丢弃的原因。

  ICMP 报文像 TCP/UDP 一样通过 IP 进行传输，但是 ICMP 的功能不是传输层的补充，应该把它当做网络层协议。

  **ICMP 头部**封装字段如下图。

  ![img](https://pic2.zhimg.com/80/v2-56541d0895cfcc5267752e02d34ae759_720w.webp)

通过**类型**字段和**编码**字段的取值判断这个 ICMP 消息的类型。常见的 ICMP 消息所对应的类型和编码值如下图。

![img](https://pic2.zhimg.com/80/v2-6f067e275fd8556ba3b1eb720329999d_720w.webp)

从功能上，ICMP 的消息分为两类：一类是通知出错原因的**错误消息**，另一类是用于诊断的**查询消息**。

![img](https://pic3.zhimg.com/80/v2-2d5f2c0b3484583193fab8452a55fa6e_720w.webp)

### ping

我们常用的 **ping 工具**就是通过 ICMP 消息测试网络层连通性的。源主机发出 Echo request 消息，目的主机回应 Echo reply 消息，则两台主机间的网络层通信正常。也可以通过 ping 命令来判断目标主机是否启用。

参考资料：

https://zhuanlan.zhihu.com/p/363651969#:~:text=%E7%99%BB%E5%BD%95/%E6%B3%A8%E5%86%8C-,71%E5%BC%A0%E5%9B%BE%E8%AF%A6%E8%A7%A3IP%20%E5%9C%B0%E5%9D%80%E3%80%81IP%20%E8%B7%AF%E7%94%B1%E3%80%81%E5%88%86%E7%89%87%E5%92%8C%E9%87%8D%E7%BB%84%E3%80%81%E4%B8%89%E5%B1%82%E8%BD%AC%E5%8F%91%E3%80%81ARP%E3%80%81ICMP,-%E7%BD%91%E5%B7%A5Fox